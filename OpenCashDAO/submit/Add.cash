pragma cashscript ^0.11.0;

contract ProposalToAdd() {
  /**
   * ProposalNFT structure:
   * - ProposalID: 4 bytes
   * - ThreadLeft: 2 bytes
   * - ThreadCount: 2 bytes
   * - ProposedScriptHash: 32 bytes
   *
   * If the proposalNFT is mutable AND threadLeft is 0 then the voting is still happening.
   * If the proposalNFT is mutable AND threadLeft is not 0 then the proposal has passed and the threadCount is updated and it needs to go through the ExecuteProposal contract.
   * If the proposalNFT is immutable then it's finalised and all the threads are dealt with.
   *
   * @inputs
   * - Input0: DAO Contract's authorizedThreadNFT i.e immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract
   * - Input2: Minting NFT of the project
   * - Input3: Funding UTXO
   * 
   * @outputs
   * - Output0: DAO Contract's authorizedThreadNFT back to DAO Contract
   * - Output1: Input1 back to this contract without any change
   * - Output2: Minting NFT back to DAO Contract
   * - Output3: Proposal NFT to DAO contract
   * - Output4: OP_RETURN with the proposal data
   * - Output5: Change pure BCH
   */
  function call(bytes32 proposalScriptHash, int threadCount) {
    require(tx.inputs.length == 4);
    require(tx.outputs.length <= 6);

    // This contract can only be used at input1 and it should return the input1 back to itself.
    require(this.activeInputIndex == 1);
    require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode);
    // Ensure that the domainCategory in not minted here.
    require(tx.outputs[this.activeInputIndex].tokenCategory == 0x);

    // This contract can only be used with the 'lockingbytecode' used in the 0th input.
    // Note: This contract can be used with any contract that fulfills these conditions, and that is fine
    // because those contracts will not be manipulating the utxos of the Registry contract. Instead, they will
    // be manipulating their own utxos.
    bytes daoInputLockingBytecode = tx.inputs[0].lockingBytecode;
    require(tx.inputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[3].lockingBytecode == daoInputLockingBytecode);

    // Proposal NFT ID increases by 1 with each transaction.
    int prevProposalNftId = int(tx.inputs[3].nftCommitment.reverse());
    int nextProposalNftId = int(tx.outputs[3].nftCommitment.reverse());
    require(nextProposalNftId == prevProposalNftId + 1);

    // scriptHash of the contract.

    // ThreadsLeft: 2 bytes
    // Thread count: 2 bytes
    // ProposalID: 4 bytes
    // If status is 2: Proposed Script Hash: 32 bytes

    // in replacement, it keeps the same proposalId.

    // Initially the first 2 bytes must be set correctly.

    // The length of the proposalNFT should be 1 + 1 + 2 + 32 = 36 bytes.

    // It must use the thread NFT from the project contract if the intent is 0.

    // Anyone can create a proposal.
    // The data for that proposal must be added to the OP_RETURN.
    // and the bytecode must be added and it should be minted here.

    // Voting begins as soon as the proposal is created and runs for
    // votingWindow time.

    // Two NFTs are created, 1 is the voting NFT and the other is the proposal NFT.
    // The voting NFT will keep the votes
    // The proposal NFT will only be used after the votingWindow is over
    // The NFT will be burned after the proposal is executed independent of whether it passes or not.


  }
}