pragma cashscript ^0.11.0;


contract OpenCashDAO(
  bytes32 daoCategory
) {

  // Proposal minting NFT, starts from 0
  // Minting NFT is for minting new Proposals and ProposalCounter
  // Mutable NFTs are the Proposal NFTs
  // Immutable NFTs are the AuthorizedThreadNFT as well as Finalised Proposal NFTs

  // AuthorizedThreadNFTs are 35 in length
  // AddProposalNFT is 40 bytes
  // RemoveProposalNFT is 6 bytes
  // ReplaceProposalNFT is 36 bytes

  /**
   * @inputs
   * - Input0: AuthorizedThreadNFT from self
   * - Input1: Any UTXO from Authorized contract
   * 
   * @outputs
   * - Output0: AuthorizedThreadNFT back to self
   * - Output1: Output back to Authorized contract to be reused again
   */
  function call(){
    // Added as safeguard.
    require(tx.version == 2);

    // DAO Contract

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    // authorizedThreadNFT must stay with the DAO Contract.
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);

    require(tx.inputs[0].tokenCategory == daoCategory);
    require(tx.outputs[0].tokenCategory == daoCategory);
    // Keeping the value same to not influence any satoshi movement in authorized contracts
    require(tx.outputs[0].value == tx.inputs[0].value);
    // The commitment that has the lockingbytecode of the authorized contract should never change.
    require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);
    // Not checking the tokenAmount as it changes.

    // Authorized Contract

    // Expect the NFT commitment that contains the lockingBytecode of the authorized contract.
    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);
    // With these prerequisites met, we just need to make sure that all the contracts that are deployed are written
    // and initialized properly, and they expect this structure and handle the inputs and outputs as expected.
  }
}
