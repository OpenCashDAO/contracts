pragma cashscript ^0.11.0;

contract ExecuteProposal(
  int voteThreshold,
  int voteWindow,
  bytes32 projectCategory,
  bytes32 projectScriptHash
) {

  /**
   * @inputs
   * - Input0: DAO Contract's authorizedThreadNFT i.e immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract.
   * - Input2: Minting NFT of the project
   * - Input3: Proposal NFT (mutable)
   * - Input4: Funding UTXO
   * 
   * @outputs
   * - Output0: DAO Contract's authorizedThreadNFT back to DAO Contract
   * - Output1: Input1 back to this contract without any change.
   * - Output2: Minting NFT back to DAO Contract
   * - Output3: Immutable Proposal NFT sent to the DAO Contract for voters to get back their tokens
   * - Output4: Proposal NFT with lockingBytecode to the Project Contract
   * - Output5: Change pure BCH
   */
  function call() {
    // Length of the mintingNFT should be 4 bytes


    // The window as arrived and the proposal must be executed.
    // Voting and Proposal NFTs are burned.
    // The proposal is executed.
    // If it passes then send the new NFT to the controller contract.

    // If the intent was to remove a locking bytecode, then we call the 



    // The first 2 bytes of the Lockingbytecode of the nftCommitment from the project contract is the thread count.
    // The thread count is the number of thread that can be created or should be removed.

    // If the intent is to remove then the thread count of the proposal and the nftCommitment bytecode should be the same else proposal fails to evecute.

    // If the intent is to add then this function can be called that many number of times and will create a new thread each time and update the thread count in the
    // mutable proposal NFT.
  }
}