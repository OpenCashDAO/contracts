pragma cashscript ^0.11.0;

/**
  * @param daoCategory - The category of the DAO NFTs. [In reverse order]
 */
contract Controller(
  bytes32 daoCategory
) {
  /**
   * The Controller holds:
   * - AuthorizedThreadNFTs (immutable, daoCategory, 35 bytes)
   *   - ProposalToAdd:       	   	[~x threads]
   *   - ProposalToRemove:    	   	[~x threads]
   *   - ProposalToReplace:     	  [~x threads]
   *   - ExecuteAddProposal:     		[~x threads]
   *   - ExecuteRemoveProposal:  		[~x threads]
   *   - ExecuteReplaceProposal:	  [~x threads]
   *   - FailProposal:	       	    [~x threads]
   *   - Vote:                 	  	[~x threads]
   *   - RetractVote:          	    [~x threads]
   * - ProposalCounterNFT, (minting, daoCategory, 4 bytes)                      [1 thread]
   * - TimeProposalNFT, (immutable, daoCategory, 29 bytes)                      [1 thread/proposal]
   * - VoteProposalNFTs are mutable/immutable NFTs of daoCategory
   *   - NFT created by `ProposalToAdd` Contract the commitment length is 40 bytes and is mutable.
   *   - NFT created by `ProposalToRemove` Contract the commitment length is 6 bytes and is mutable.
   *   - NFT created by `ProposalToReplace` Contract the commitment length is 38 bytes and is mutable.
   *   Once all the threads are created/removed/replaced, the NFT becomes immutable.
   * - UpgradableContractNFT, (minting, upgradableCategory, 0 bytes)            [1 thread]
   *
   * Each voter is issued a voteNFT when they cast a vote.
   * - VoteNFT, (immutable, daoCategory, 12 bytes) <ProposalId><VoteAmount>
   *
   * Once the voting is over, the proposalNFT becomes immutable, making it un-usable for any other contract
   * It also means that the proposal has ended.
   *
   * The users are not allowed to retractVotes when proposal is being executed.
   *
   * @inputs
   * - Input0: AuthorizedThreadNFT from self
   * - Input1: Any UTXO from Authorized contract
   * 
   * @outputs
   * - Output0: AuthorizedThreadNFT back to self
   * - Output1: Output back to Authorized contract to be reused again
   */
  function call(){
    // Added as safeguard.
    require(tx.version == 2);

    // Controller Contract

    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;
    // authorizedThreadNFT must stay with the DAO Contract.
    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);
    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);

    require(tx.inputs[0].tokenCategory == daoCategory);
    require(tx.outputs[0].tokenCategory == daoCategory);
    // Keeping the value same to not influence any satoshi movement in authorized contracts
    require(tx.outputs[0].value == tx.inputs[0].value);
    // The commitment that has the lockingbytecode of the authorized contract should never change.
    require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);
    // Not checking the tokenAmount as it changes.

    // Authorized Contract

    // Expect the NFT commitment that contains the lockingBytecode of the authorized contract.
    require(tx.inputs[0].nftCommitment.length == 35);

    // TODO: Uncomment this, commented out because of cashscript bug
    // require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);
    // With these prerequisites met, we just need to make sure that all the contracts that are deployed are written
    // and initialized properly, and they expect this structure and handle the inputs and outputs as expected.
  }
}
