pragma cashscript ^0.11.0;

/**
 * @param commitmentDeposit - The amount of sathoshis the creator has to commit to the proposal.
 * - It prevents spam of proposals, reducing confusion among the stakeholders and reduces the risk of vote splitting.
 * - It requires a commitment from the creator to go ensure that the proposal is widely accepted and socially agreed upon among the shareholders of the DAO
 * If the proposal passes, the creator will get back the commitmentDeposit.
 * If the proposal fails, the BCH is sent to anyone who calls the `FailProposal` contract.
 */
contract ProposalToRemove(int minCommitmentDeposit) {
  /**
   *
   * @inputs
   * - Input0: DAO Contract's authorizedThreadNFT i.e immutable NFT with commitment that has the lockingBytecode of this contract
   *   - capability: immutable
   *   - length: 35 bytes
   *   - category: daoCategory
   * - Input1: Any input from this contract
   * - Input2: ProposalCounterNFT from DAO Contract
   *   - capability: minting
   *   - length: 4 bytes
   *   - category: daoCategory
   * - Input3: AuthorizedThreadNFT from the Project Contract 
   * - Input4: Funding UTXO
   *   - value: >= commitmentDeposit
   * 
   * @outputs
   * - Output0: DAO Contract's authorizedThreadNFT back to DAO Contract
   *   - capability: immutable
   *   - length: 35 bytes
   *   - category: daoCategory
   * - Output1: Input1 back to this contract without any change
   * - Output2: ProposalCounterNFT back to DAO Contract
   *   - capability: minting
   *   - length: 4 bytes
   *   - category: daoCategory
   * - Output3: VoteProposalNFT to DAO contract
   *   - capability: mutable
   *   - length: 6 bytes <ProposalID (4 bytes), ThreadLeft (2 bytes)>
   *   - category: daoCategory
   * - Output4: TimeProposalNFT to DAO contract
   *   - capability: immutable
   *   - length: >=29 bytes <ProposalID (4 bytes), CreatorLockingBytecode (25 bytes)>
   *   - category: daoCategory
   *   - satoshis >= commitmentDeposit
   * - Output5: AuthorizedThreadNFT back to the Project Contract
   * - Output6: OP_RETURN with the proposal data
   * - Output7: Change pure BCH
   */
  function call() {
    require(tx.inputs.length == 5);
    require(tx.outputs.length <= 8);

    // This contract can only be used at input1 and it should return the input1 back to itself.
    require(this.activeInputIndex == 1);
    require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode);
    // Ensure that the domainCategory in not minted here.
    require(tx.outputs[this.activeInputIndex].tokenCategory == 0x);

    // Proposal NFT ID stays the same
    require(tx.outputs[2].nftCommitment == tx.inputs[2].nftCommitment);

    // This contract can only be used with the 'lockingbytecode' used in the 0th input.
    // Note: This contract can be used with any contract that fulfills these conditions, and that is fine
    // because those contracts will not be manipulating the utxos of the Registry contract. Instead, they will
    // be manipulating their own utxos.
    bytes daoInputLockingBytecode = tx.inputs[0].lockingBytecode;
    require(tx.inputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[3].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[4].lockingBytecode == daoInputLockingBytecode);

    // ProposalCounterNFT should always be 4 bytes
    require(tx.outputs[2].nftCommitment.length == 4);
    // ProposalCounterNFT should keep the same category and capability.
    require(tx.outputs[2].tokenCategory == tx.inputs[2].tokenCategory);

    bytes daoInputCategory = tx.inputs[0].tokenCategory;

    // ProposalCounterNFT should be minting and of the 'daoInputCategory'
    bytes proposalCounterCategory, bytes proposalCounterCapability = tx.outputs[2].tokenCategory.split(32);
    require(proposalCounterCategory == daoInputCategory);
    require(proposalCounterCapability == 0x02); // Minting

    // VoteProposalNFT should be mutable
    bytes voteProposalCategory, bytes voteProposalCapability = tx.outputs[3].tokenCategory.split(32);
    require(voteProposalCategory == daoInputCategory);
    require(voteProposalCapability == 0x01); // Mutable

    // TimeProposalNFT should be immutable
    require(tx.outputs[4].tokenCategory == daoInputCategory);
    
    // Ensure funding is pure BCH and is >= commitmentDeposit
    require(tx.inputs[4].tokenCategory == 0x);
    require(tx.inputs[4].value >= minCommitmentDeposit);
    // Ensure the TimeProposalNFT has the same value as the commitmentDeposit
    require(tx.outputs[4].value >= minCommitmentDeposit);

    // REMOVE: Take the proposalID<4 bytes> and threadLeft<2 bytes> from the AuthorizedThreadNFT
    require(tx.outputs[3].nftCommitment == tx.inputs[3].nftCommitment.split(6)[0]);
    require(tx.outputs[3].nftCommitment.length == 6);

    // @todo: Uncomment this, commented out because of cashscript bug
    // Set the commitment for the TimeProposalNFT <proposalID<4 bytes>, CreatorLockingBytecode<any length bytes>>
    // require(tx.outputs[4].nftCommitment == tx.inputs[3].nftCommitment.split(4)[0] + tx.inputs[4].lockingBytecode);

    // Return the AuthorizedThreadNFT back to the Project Contract as it was in the input
    require(tx.inputs[3].lockingBytecode == tx.outputs[5].lockingBytecode);
    require(tx.inputs[3].tokenCategory == tx.outputs[5].tokenCategory);
    require(tx.inputs[3].nftCommitment == tx.outputs[5].nftCommitment);
    require(tx.inputs[3].value == tx.outputs[5].value);

    // Force OP_RETURN output
    require(tx.outputs[6].value == 0);    

    // Ensure change is pure BCH
    require(tx.outputs[7].tokenCategory == 0x);

  }
}