pragma cashscript ^0.11.0;

contract RetractVote() {
  /**
   * @inputs
   * - Input0: DAO Contract's authorizedThreadNFT i.e immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract.
   * - Input2: VoteProposalNFT (with tokenAmount)
   * - Input3: RecieptNFT used to cast vote
   * - Input4: Funding UTXO
   * 
   * @outputs
   * - Output0: DAO Contract's authorizedThreadNFT back to self
   * - Output1: Input1 back to this contract without any change.
   * - Output2: VoteProposalNFT back to DAO (minus the tokenAmount in the recieptNFT)
   * - Output3: tokenAmount to the recieptNFT provider
   * - Output4: Change pure BCH
   */
  function call() {
    require(tx.inputs.length == 5);
    require(tx.outputs.length <= 5);

    // This contract can only be used at input1 and it should return the input1 back to itself.
    require(this.activeInputIndex == 1);
    require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode);
  
    // This contract can only be used with the 'lockingbytecode' used in the 0th input.
    // Note: This contract can be used with any contract that fulfills these conditions, and that is fine
    // because those contracts will not be manipulating the utxos of the Registry contract. Instead, they will
    // be manipulating their own utxos.
    bytes daoInputLockingBytecode = tx.inputs[0].lockingBytecode;
    require(tx.inputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.inputs[3].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[3].lockingBytecode == daoInputLockingBytecode);

    bytes daoInputCategory = tx.inputs[0].tokenCategory;

    // daoMintingNFT should be minting and of the 'daoInputCategory'
    bytes daoMintingCategory, bytes daoMintingCapability = tx.outputs[2].tokenCategory.split(32);
    require(daoMintingCategory == daoInputCategory);
    require(daoMintingCapability == 0x02); // Minting

    // VoteProposalNFT should be mutable
    bytes voteProposalCategory, bytes voteProposalCapability = tx.outputs[3].tokenCategory.split(32);
    require(voteProposalCategory == daoInputCategory);
    require(voteProposalCapability == 0x01); // Mutable

    require(tx.outputs[3].tokenAmount == tx.inputs[3].tokenAmount + voteAmount);

    // The nftCommitment of the funding UTXO should be 40 bytes for AddProposal, 6 bytes for RemoveProposal and 36 bytes for ReplaceProposal
    int voteProposalLength = tx.inputs[3].nftCommitment.length;
    require(voteProposalLength == 40 || voteProposalLength == 6 || voteProposalLength == 36);

    // Split the nftCommitment of the proposalNFT and take the first 4 bytes as the proposalId
    require(tx.outputs[4].nftCommitment == tx.inputs[3].nftCommitment.split(4)[0]);

    require(tx.inputs[4].tokenCategory == daoInputCategory);
    require(tx.outputs[5].tokenCategory == daoInputCategory);

    require(tx.inputs[4].value >= voteAmount);
    require(tx.outputs[5].value == tx.inputs[4].value - voteAmount);
    require(tx.outputs[5].nftCommitment == 0x);
  }
}