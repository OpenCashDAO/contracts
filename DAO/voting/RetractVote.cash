pragma cashscript ^0.11.0;

contract RetractVote() {
  /**
   * @inputs
   * - Input0: DAO Contract's authorizedThreadNFT i.e immutable NFT with commitment that has the lockingBytecode of this contract
   * - Input1: Any input from this contract.
   * - Input2: VoteProposalNFT from DAO
   * - Input3: RecieptNFT used to cast vote
   * - Input4: Funding UTXO               
   * 
   * @outputs
   * - Output0: DAO Contract's authorizedThreadNFT back to self
   * - Output1: Input1 back to this contract without any change.
   * - Output2: VoteProposalNFT back to DAO (minus the tokenAmount in the recieptNFT)
   * - Output3: tokenAmount to the recieptNFT provider
   * - Output4: Change pure BCH
   */
  function call() {
    require(tx.inputs.length == 5);
    require(tx.outputs.length <= 5);

    // This contract can only be used at input1 and it should return the input1 back to itself.
    require(this.activeInputIndex == 1);
    require(tx.inputs[this.activeInputIndex].lockingBytecode == tx.outputs[this.activeInputIndex].lockingBytecode);
  
    // This contract can only be used with the 'lockingbytecode' used in the 0th input.
    // Note: This contract can be used with any contract that fulfills these conditions, and that is fine
    // because those contracts will not be manipulating the utxos of the Registry contract. Instead, they will
    // be manipulating their own utxos.
    bytes daoInputLockingBytecode = tx.inputs[0].lockingBytecode;
    require(tx.inputs[2].lockingBytecode == daoInputLockingBytecode);
    require(tx.outputs[2].lockingBytecode == daoInputLockingBytecode);

    bytes daoInputCategory = tx.inputs[0].tokenCategory;
    require(tx.inputs[3].tokenCategory == daoInputCategory);
    require(tx.outputs[3].tokenCategory == daoInputCategory);

    // VoteProposalNFT should be mutable
    bytes voteProposalCategory, bytes voteProposalCapability = tx.outputs[2].tokenCategory.split(32);
    require(voteProposalCategory == daoInputCategory);
    require(voteProposalCapability == 0x01 || voteProposalCapability == 0x); // Mutable or immutable

    bytes proposalId, bytes voteAmountBytes = tx.inputs[3].nftCommitment.split(4);
    require(tx.inputs[3].nftCommitment.length == 12);

    int voteAmount = int(voteAmountBytes);

    require(tx.outputs[3].tokenAmount == tx.inputs[3].tokenAmount - voteAmount);
    require(tx.outputs[2].tokenAmount == tx.inputs[2].tokenAmount + voteAmount);

    // Compare projectID i.e the first 4 bytes of the nftCommitment
    require(proposalId == tx.inputs[2].nftCommitment.split(4)[0]);

    require(tx.outputs[4].value == tx.inputs[3].value);
    require(tx.outputs[4].nftCommitment == 0x);
  }
}